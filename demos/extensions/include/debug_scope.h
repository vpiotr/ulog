#ifndef ULOG_DEBUG_SCOPE_H
#define ULOG_DEBUG_SCOPE_H

/**
 * @file debug_scope.h
 * @brief Debug scope RAII extension for ulog
 * @author ulog team
 * @version 1.0.0
 * 
 * This extension provides DebugScope RAII functionality and DebugObserver
 * for automatic scope entry/exit logging. The DebugScope class automatically
 * logs "Entering: x" and "Exiting: x" messages for labeled scopes using the
 * RAII pattern, while DebugObserver can track and capture these messages.
 */

#include "ulog/ulog.h"
#include <iostream>
#include <memory>
#include <string>
#include <vector>

namespace ulog {
namespace extensions {

/**
 * @brief Debug observer that specifically tracks debug scope entries
 * 
 * This observer captures and tracks debug scope entry/exit messages.
 * It can be used to monitor scope traversal and provide debugging
 * information about program flow.
 * 
 * @code{.cpp}
 * auto& logger = ulog::getLogger("demo");
 * auto observer = std::make_shared<DebugObserver>("ScopeTracker");
 * 
 * {
 *     ulog::ObserverScope observerScope(logger, observer);
 *     {
 *         DebugScope scope(logger, "main_function");
 *         // ... do work ...
 *     }
 * }
 * 
 * observer->printCapturedMessages();
 * @endcode
 */
class DebugObserver : public ulog::LogObserver {
public:
    /**
     * @brief Constructor
     * @param name Name/identifier for this observer instance
     */
    explicit DebugObserver(const std::string& name) : name_(name) {}
    
    /**
     * @brief Handle new log message
     * @param entry Log entry to process
     * 
     * Captures messages that contain "Entering:" or "Exiting:" patterns,
     * which are typically generated by DebugScope instances.
     */
    void handleNewMessage(const ulog::LogEntry& entry) override {
        // Track all debug scope related messages
        if (entry.message.find("Entering:") != std::string::npos ||
            entry.message.find("Exiting:") != std::string::npos) {
            scope_messages_.push_back(entry.message);
            std::cout << "[" << name_ << "] Captured: " << entry.formatted_message() << std::endl;
        }
    }
    
    /**
     * @brief Handle observer registration
     * @param logger_name Name of the logger this observer was registered with
     */
    void handleRegistered(const std::string& logger_name) override {
        std::cout << "[" << name_ << "] Observer registered for logger: " << logger_name << std::endl;
    }
    
    /**
     * @brief Handle observer unregistration
     * @param logger_name Name of the logger this observer was unregistered from
     */
    void handleUnregistered(const std::string& logger_name) override {
        std::cout << "[" << name_ << "] Observer unregistered from logger: " << logger_name << std::endl;
    }
    
    /**
     * @brief Print all captured scope messages to console
     */
    void printCapturedMessages() const {
        std::cout << "[" << name_ << "] Captured " << scope_messages_.size() << " scope messages:" << std::endl;
        for (const auto& msg : scope_messages_) {
            std::cout << "  - " << msg << std::endl;
        }
    }
    
    /**
     * @brief Get the number of captured scope messages
     * @return Number of captured messages
     */
    size_t getMessageCount() const { return scope_messages_.size(); }
    
    /**
     * @brief Get all captured scope messages
     * @return Vector of captured message strings
     */
    const std::vector<std::string>& getCapturedMessages() const { return scope_messages_; }
    
    /**
     * @brief Clear all captured messages
     */
    void clearCapturedMessages() { scope_messages_.clear(); }
    
    /**
     * @brief Get the observer name
     * @return Observer name/identifier
     */
    const std::string& getName() const { return name_; }
    
private:
    std::string name_;
    std::vector<std::string> scope_messages_;
};

/**
 * @brief RAII debug scope that logs entering and exiting messages
 * 
 * This class implements the RAII pattern to automatically log scope
 * entry and exit messages. When constructed, it logs an "Entering: scope_name"
 * message. When destroyed (either normally or due to exception), it logs
 * an "Exiting: scope_name" message.
 * 
 * The class is non-copyable and non-movable to ensure proper RAII semantics.
 * 
 * @code{.cpp}
 * auto& logger = ulog::getLogger("demo");
 * logger.set_log_level(ulog::LogLevel::DEBUG);
 * 
 * {
 *     DebugScope scope(logger, "main_function");
 *     logger.info("Doing work in main function");
 *     // Automatically logs "Exiting: main_function" when scope ends
 * }
 * @endcode
 */
class DebugScope {
public:
    /**
     * @brief Constructor - logs entering message
     * @param logger Logger to use for debug messages
     * @param scope_name Name/label of the scope
     * 
     * Logs a debug message with format "Entering: {scope_name}"
     */
    DebugScope(ulog::Logger& logger, const std::string& scope_name)
        : logger_(logger), scope_name_(scope_name) {
        logger_.debug("Entering: {0}", scope_name_);
    }
    
    /**
     * @brief Destructor - logs exiting message
     * 
     * Logs a debug message with format "Exiting: {scope_name}".
     * This is guaranteed to be called even if an exception occurs
     * within the scope due to RAII semantics.
     */
    ~DebugScope() {
        logger_.debug("Exiting: {0}", scope_name_);
    }
    
    // Non-copyable, non-movable to ensure proper RAII semantics
    DebugScope(const DebugScope&) = delete;
    DebugScope& operator=(const DebugScope&) = delete;
    DebugScope(DebugScope&&) = delete;
    DebugScope& operator=(DebugScope&&) = delete;
    
    /**
     * @brief Get the scope name
     * @return Scope name/label
     */
    const std::string& getScopeName() const { return scope_name_; }
    
    /**
     * @brief Get reference to the logger
     * @return Logger reference
     */
    ulog::Logger& getLogger() const { return logger_; }

private:
    ulog::Logger& logger_;
    std::string scope_name_;
};

} // namespace extensions
} // namespace ulog

#endif // ULOG_DEBUG_SCOPE_H
